package com.qifan.uipractice3.practice;

/**
 * Created by Qifan on 2018/8/24.
 */

import android.graphics.Paint;
import android.graphics.PorterDuff;
import android.graphics.PorterDuffXfermode;
import android.graphics.RectF;
import android.graphics.BlurMaskFilter;
import android.graphics.Canvas;
import android.graphics.Color;
import android.graphics.Path;



/**
 * Created by AuthorName on 24 Aug 2018.
 * Copyright Â© 2018 CompanyName. All rights reserved.
 *
 * This code was generated by Trial version of PaintCode, therefore cannot be used for commercial purposes.
 * http://www.paintcodeapp.com
 *
 * @author AuthorName
 */
public class StyleKitName {
    private static class GlobalCache {
        static PorterDuffXfermode blendModeDestinationOut = new PorterDuffXfermode(PorterDuff.Mode.DST_OUT);
    }

    // Resizing Behavior
    public enum ResizingBehavior {
        AspectFit, //!< The content is proportionally resized to fit into the target rectangle.
        AspectFill, //!< The content is proportionally resized to completely fill the target rectangle.
        Stretch, //!< The content is stretched to match the entire target rectangle.
        Center, //!< The content is centered in the target rectangle, but it is NOT resized.
    }

    // In Trial version of PaintCode, the code generation is limited to 3 canvases.

    // Canvas Drawings
    // Tab

    private static class CacheForCanvas1 {
        private static Paint paint = new Paint();
        private static PaintCodeShadow shadow = new PaintCodeShadow();
        private static RectF originalFrame = new RectF(0f, 0f, 240f, 120f);
        private static RectF resizedFrame = new RectF();
        private static RectF rectangleRect = new RectF();
        private static Path rectanglePath = new Path();
        private static float[] rectangleCornerRadii = new float[8];
    }

    public static void drawCanvas1(Canvas canvas) {
        StyleKitName.drawCanvas1(canvas, new RectF(0f, 0f, 240f, 120f), ResizingBehavior.AspectFit);
    }

    public static void drawCanvas1(Canvas canvas, RectF targetFrame, ResizingBehavior resizing) {
        // General Declarations
        Paint paint = CacheForCanvas1.paint;

        // Local Colors
        int color2 = Color.argb(255, 245, 243, 243);
        int color = Color.argb(255, 208, 61, 35);

        // Local Shadows
        PaintCodeShadow shadow = CacheForCanvas1.shadow.get(Color.DKGRAY, 1f, 2f, 3f);

        // Resize to Target Frame
        canvas.save();
        RectF resizedFrame = CacheForCanvas1.resizedFrame;
        StyleKitName.resizingBehaviorApply(resizing, CacheForCanvas1.originalFrame, targetFrame, resizedFrame);
        canvas.translate(resizedFrame.left, resizedFrame.top);
        canvas.scale(resizedFrame.width() / 240f, resizedFrame.height() / 120f);

        // Rectangle
        RectF rectangleRect = CacheForCanvas1.rectangleRect;
        rectangleRect.set(50.5f, 49.5f, 84.5f, 83.5f);
        Path rectanglePath = CacheForCanvas1.rectanglePath;
        rectanglePath.reset();
        float rectangleCornerRadius = Math.min(Math.min(rectangleRect.width(), rectangleRect.height()) / 2f, 17f);
        float[] rectangleCornerRadii = CacheForCanvas1.rectangleCornerRadii;
        rectangleCornerRadii[0] = rectangleCornerRadii[1] = rectangleCornerRadius;
        rectangleCornerRadii[2] = rectangleCornerRadii[3] = 0f;
        rectangleCornerRadii[4] = rectangleCornerRadii[5] = rectangleCornerRadius;
        rectangleCornerRadii[6] = rectangleCornerRadii[7] = rectangleCornerRadius;
        rectanglePath.addRoundRect(rectangleRect, rectangleCornerRadii, Path.Direction.CW);

        paint.reset();
        paint.setFlags(Paint.ANTI_ALIAS_FLAG);
        paint.setStyle(Paint.Style.FILL);
        paint.setColor(color);
        canvas.drawPath(rectanglePath, paint);
        canvas.saveLayerAlpha(null, 255, Canvas.ALL_SAVE_FLAG);
        {

            paint.reset();
            paint.setFlags(Paint.ANTI_ALIAS_FLAG);
            paint.setColor(shadow.color);
            canvas.drawPath(rectanglePath, paint);

            paint.reset();
            paint.setFlags(Paint.ANTI_ALIAS_FLAG);
            paint.setXfermode(GlobalCache.blendModeDestinationOut);
            canvas.saveLayer(null, paint, Canvas.ALL_SAVE_FLAG);
            {
                canvas.translate(shadow.dx, shadow.dy);


                paint.reset();
                paint.setFlags(Paint.ANTI_ALIAS_FLAG);
                paint.setColor(Color.WHITE);
                shadow.setBlurOfPaint(paint);
                canvas.drawPath(rectanglePath, paint);
            }
            canvas.restore();
        }
        canvas.restore();

        paint.reset();
        paint.setFlags(Paint.ANTI_ALIAS_FLAG);
        paint.setStrokeWidth(2f);
        paint.setStrokeCap(Paint.Cap.ROUND);
        paint.setStrokeMiter(10f);
        canvas.save();
        paint.setStyle(Paint.Style.STROKE);
        paint.setColor(color2);
        canvas.drawPath(rectanglePath, paint);
        canvas.restore();

        canvas.restore();
    }


    // Resizing Behavior
    public static void resizingBehaviorApply(ResizingBehavior behavior, RectF rect, RectF target, RectF result) {
        if (rect.equals(target) || target == null) {
            result.set(rect);
            return;
        }

        if (behavior == ResizingBehavior.Stretch) {
            result.set(target);
            return;
        }

        float xRatio = Math.abs(target.width() / rect.width());
        float yRatio = Math.abs(target.height() / rect.height());
        float scale = 0f;

        switch (behavior) {
            case AspectFit: {
                scale = Math.min(xRatio, yRatio);
                break;
            }
            case AspectFill: {
                scale = Math.max(xRatio, yRatio);
                break;
            }
            case Center: {
                scale = 1f;
                break;
            }
        }

        float newWidth = Math.abs(rect.width() * scale);
        float newHeight = Math.abs(rect.height() * scale);
        result.set(target.centerX() - newWidth / 2,
                target.centerY() - newHeight / 2,
                target.centerX() + newWidth / 2,
                target.centerY() + newHeight / 2);
    }


}

